/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// @ts-nocheck
/**
 * This file exports the `Diagnosis` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from '@prisma/client/runtime/library';
import type * as $Enums from '../enums';
import type * as Prisma from '../internal/prismaNamespace';

/**
 * Model Diagnosis
 *
 */
export type DiagnosisModel = runtime.Types.Result.DefaultSelection<Prisma.$DiagnosisPayload>;

export type AggregateDiagnosis = {
    _count: DiagnosisCountAggregateOutputType | null;
    _avg: DiagnosisAvgAggregateOutputType | null;
    _sum: DiagnosisSumAggregateOutputType | null;
    _min: DiagnosisMinAggregateOutputType | null;
    _max: DiagnosisMaxAggregateOutputType | null;
};

export type DiagnosisAvgAggregateOutputType = {
    id: number | null;
    medicalId: number | null;
};

export type DiagnosisSumAggregateOutputType = {
    id: number | null;
    medicalId: number | null;
};

export type DiagnosisMinAggregateOutputType = {
    id: number | null;
    patientId: string | null;
    medicalId: number | null;
    doctorId: string | null;
    symptoms: string | null;
    diagnosis: string | null;
    notes: string | null;
    prescribedMedications: string | null;
    followUpPlan: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
};

export type DiagnosisMaxAggregateOutputType = {
    id: number | null;
    patientId: string | null;
    medicalId: number | null;
    doctorId: string | null;
    symptoms: string | null;
    diagnosis: string | null;
    notes: string | null;
    prescribedMedications: string | null;
    followUpPlan: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
};

export type DiagnosisCountAggregateOutputType = {
    id: number;
    patientId: number;
    medicalId: number;
    doctorId: number;
    symptoms: number;
    diagnosis: number;
    notes: number;
    prescribedMedications: number;
    followUpPlan: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
};

export type DiagnosisAvgAggregateInputType = {
    id?: true;
    medicalId?: true;
};

export type DiagnosisSumAggregateInputType = {
    id?: true;
    medicalId?: true;
};

export type DiagnosisMinAggregateInputType = {
    id?: true;
    patientId?: true;
    medicalId?: true;
    doctorId?: true;
    symptoms?: true;
    diagnosis?: true;
    notes?: true;
    prescribedMedications?: true;
    followUpPlan?: true;
    createdAt?: true;
    updatedAt?: true;
};

export type DiagnosisMaxAggregateInputType = {
    id?: true;
    patientId?: true;
    medicalId?: true;
    doctorId?: true;
    symptoms?: true;
    diagnosis?: true;
    notes?: true;
    prescribedMedications?: true;
    followUpPlan?: true;
    createdAt?: true;
    updatedAt?: true;
};

export type DiagnosisCountAggregateInputType = {
    id?: true;
    patientId?: true;
    medicalId?: true;
    doctorId?: true;
    symptoms?: true;
    diagnosis?: true;
    notes?: true;
    prescribedMedications?: true;
    followUpPlan?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
};

export type DiagnosisAggregateArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
    /**
     * Filter which Diagnosis to aggregate.
     */
    where?: Prisma.DiagnosisWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Diagnoses to fetch.
     */
    orderBy?: Prisma.DiagnosisOrderByWithRelationInput | Prisma.DiagnosisOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: Prisma.DiagnosisWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Diagnoses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Diagnoses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Diagnoses
     **/
    _count?: true | DiagnosisCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: DiagnosisAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: DiagnosisSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: DiagnosisMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: DiagnosisMaxAggregateInputType;
};

export type GetDiagnosisAggregateType<T extends DiagnosisAggregateArgs> = {
    [P in keyof T & keyof AggregateDiagnosis]: P extends '_count' | 'count'
        ? T[P] extends true
            ? number
            : Prisma.GetScalarType<T[P], AggregateDiagnosis[P]>
        : Prisma.GetScalarType<T[P], AggregateDiagnosis[P]>;
};

export type DiagnosisGroupByArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
    where?: Prisma.DiagnosisWhereInput;
    orderBy?: Prisma.DiagnosisOrderByWithAggregationInput | Prisma.DiagnosisOrderByWithAggregationInput[];
    by: Prisma.DiagnosisScalarFieldEnum[] | Prisma.DiagnosisScalarFieldEnum;
    having?: Prisma.DiagnosisScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: DiagnosisCountAggregateInputType | true;
    _avg?: DiagnosisAvgAggregateInputType;
    _sum?: DiagnosisSumAggregateInputType;
    _min?: DiagnosisMinAggregateInputType;
    _max?: DiagnosisMaxAggregateInputType;
};

export type DiagnosisGroupByOutputType = {
    id: number;
    patientId: string;
    medicalId: number;
    doctorId: string;
    symptoms: string;
    diagnosis: string;
    notes: string | null;
    prescribedMedications: string | null;
    followUpPlan: string | null;
    createdAt: Date;
    updatedAt: Date;
    _count: DiagnosisCountAggregateOutputType | null;
    _avg: DiagnosisAvgAggregateOutputType | null;
    _sum: DiagnosisSumAggregateOutputType | null;
    _min: DiagnosisMinAggregateOutputType | null;
    _max: DiagnosisMaxAggregateOutputType | null;
};

type GetDiagnosisGroupByPayload<T extends DiagnosisGroupByArgs> = Prisma.PrismaPromise<
    Array<
        Prisma.PickEnumerable<DiagnosisGroupByOutputType, T['by']> & {
            [P in keyof T & keyof DiagnosisGroupByOutputType]: P extends '_count'
                ? T[P] extends boolean
                    ? number
                    : Prisma.GetScalarType<T[P], DiagnosisGroupByOutputType[P]>
                : Prisma.GetScalarType<T[P], DiagnosisGroupByOutputType[P]>;
        }
    >
>;

export type DiagnosisWhereInput = {
    AND?: Prisma.DiagnosisWhereInput | Prisma.DiagnosisWhereInput[];
    OR?: Prisma.DiagnosisWhereInput[];
    NOT?: Prisma.DiagnosisWhereInput | Prisma.DiagnosisWhereInput[];
    id?: Prisma.IntFilter<'Diagnosis'> | number;
    patientId?: Prisma.StringFilter<'Diagnosis'> | string;
    medicalId?: Prisma.IntFilter<'Diagnosis'> | number;
    doctorId?: Prisma.StringFilter<'Diagnosis'> | string;
    symptoms?: Prisma.StringFilter<'Diagnosis'> | string;
    diagnosis?: Prisma.StringFilter<'Diagnosis'> | string;
    notes?: Prisma.StringNullableFilter<'Diagnosis'> | string | null;
    prescribedMedications?: Prisma.StringNullableFilter<'Diagnosis'> | string | null;
    followUpPlan?: Prisma.StringNullableFilter<'Diagnosis'> | string | null;
    createdAt?: Prisma.DateTimeFilter<'Diagnosis'> | Date | string;
    updatedAt?: Prisma.DateTimeFilter<'Diagnosis'> | Date | string;
    doctor?: Prisma.XOR<Prisma.DoctorScalarRelationFilter, Prisma.DoctorWhereInput>;
    medical?: Prisma.XOR<Prisma.MedicalRecordsScalarRelationFilter, Prisma.MedicalRecordsWhereInput>;
};

export type DiagnosisOrderByWithRelationInput = {
    id?: Prisma.SortOrder;
    patientId?: Prisma.SortOrder;
    medicalId?: Prisma.SortOrder;
    doctorId?: Prisma.SortOrder;
    symptoms?: Prisma.SortOrder;
    diagnosis?: Prisma.SortOrder;
    notes?: Prisma.SortOrderInput | Prisma.SortOrder;
    prescribedMedications?: Prisma.SortOrderInput | Prisma.SortOrder;
    followUpPlan?: Prisma.SortOrderInput | Prisma.SortOrder;
    createdAt?: Prisma.SortOrder;
    updatedAt?: Prisma.SortOrder;
    doctor?: Prisma.DoctorOrderByWithRelationInput;
    medical?: Prisma.MedicalRecordsOrderByWithRelationInput;
};

export type DiagnosisWhereUniqueInput = Prisma.AtLeast<
    {
        id?: number;
        AND?: Prisma.DiagnosisWhereInput | Prisma.DiagnosisWhereInput[];
        OR?: Prisma.DiagnosisWhereInput[];
        NOT?: Prisma.DiagnosisWhereInput | Prisma.DiagnosisWhereInput[];
        patientId?: Prisma.StringFilter<'Diagnosis'> | string;
        medicalId?: Prisma.IntFilter<'Diagnosis'> | number;
        doctorId?: Prisma.StringFilter<'Diagnosis'> | string;
        symptoms?: Prisma.StringFilter<'Diagnosis'> | string;
        diagnosis?: Prisma.StringFilter<'Diagnosis'> | string;
        notes?: Prisma.StringNullableFilter<'Diagnosis'> | string | null;
        prescribedMedications?: Prisma.StringNullableFilter<'Diagnosis'> | string | null;
        followUpPlan?: Prisma.StringNullableFilter<'Diagnosis'> | string | null;
        createdAt?: Prisma.DateTimeFilter<'Diagnosis'> | Date | string;
        updatedAt?: Prisma.DateTimeFilter<'Diagnosis'> | Date | string;
        doctor?: Prisma.XOR<Prisma.DoctorScalarRelationFilter, Prisma.DoctorWhereInput>;
        medical?: Prisma.XOR<Prisma.MedicalRecordsScalarRelationFilter, Prisma.MedicalRecordsWhereInput>;
    },
    'id'
>;

export type DiagnosisOrderByWithAggregationInput = {
    id?: Prisma.SortOrder;
    patientId?: Prisma.SortOrder;
    medicalId?: Prisma.SortOrder;
    doctorId?: Prisma.SortOrder;
    symptoms?: Prisma.SortOrder;
    diagnosis?: Prisma.SortOrder;
    notes?: Prisma.SortOrderInput | Prisma.SortOrder;
    prescribedMedications?: Prisma.SortOrderInput | Prisma.SortOrder;
    followUpPlan?: Prisma.SortOrderInput | Prisma.SortOrder;
    createdAt?: Prisma.SortOrder;
    updatedAt?: Prisma.SortOrder;
    _count?: Prisma.DiagnosisCountOrderByAggregateInput;
    _avg?: Prisma.DiagnosisAvgOrderByAggregateInput;
    _max?: Prisma.DiagnosisMaxOrderByAggregateInput;
    _min?: Prisma.DiagnosisMinOrderByAggregateInput;
    _sum?: Prisma.DiagnosisSumOrderByAggregateInput;
};

export type DiagnosisScalarWhereWithAggregatesInput = {
    AND?: Prisma.DiagnosisScalarWhereWithAggregatesInput | Prisma.DiagnosisScalarWhereWithAggregatesInput[];
    OR?: Prisma.DiagnosisScalarWhereWithAggregatesInput[];
    NOT?: Prisma.DiagnosisScalarWhereWithAggregatesInput | Prisma.DiagnosisScalarWhereWithAggregatesInput[];
    id?: Prisma.IntWithAggregatesFilter<'Diagnosis'> | number;
    patientId?: Prisma.StringWithAggregatesFilter<'Diagnosis'> | string;
    medicalId?: Prisma.IntWithAggregatesFilter<'Diagnosis'> | number;
    doctorId?: Prisma.StringWithAggregatesFilter<'Diagnosis'> | string;
    symptoms?: Prisma.StringWithAggregatesFilter<'Diagnosis'> | string;
    diagnosis?: Prisma.StringWithAggregatesFilter<'Diagnosis'> | string;
    notes?: Prisma.StringNullableWithAggregatesFilter<'Diagnosis'> | string | null;
    prescribedMedications?: Prisma.StringNullableWithAggregatesFilter<'Diagnosis'> | string | null;
    followUpPlan?: Prisma.StringNullableWithAggregatesFilter<'Diagnosis'> | string | null;
    createdAt?: Prisma.DateTimeWithAggregatesFilter<'Diagnosis'> | Date | string;
    updatedAt?: Prisma.DateTimeWithAggregatesFilter<'Diagnosis'> | Date | string;
};

export type DiagnosisCreateInput = {
    patientId: string;
    symptoms: string;
    diagnosis: string;
    notes?: string | null;
    prescribedMedications?: string | null;
    followUpPlan?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    doctor: Prisma.DoctorCreateNestedOneWithoutDiagnosisInput;
    medical: Prisma.MedicalRecordsCreateNestedOneWithoutDiagnosisInput;
};

export type DiagnosisUncheckedCreateInput = {
    id?: number;
    patientId: string;
    medicalId: number;
    doctorId: string;
    symptoms: string;
    diagnosis: string;
    notes?: string | null;
    prescribedMedications?: string | null;
    followUpPlan?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};

export type DiagnosisUpdateInput = {
    patientId?: Prisma.StringFieldUpdateOperationsInput | string;
    symptoms?: Prisma.StringFieldUpdateOperationsInput | string;
    diagnosis?: Prisma.StringFieldUpdateOperationsInput | string;
    notes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
    prescribedMedications?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
    followUpPlan?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    doctor?: Prisma.DoctorUpdateOneRequiredWithoutDiagnosisNestedInput;
    medical?: Prisma.MedicalRecordsUpdateOneRequiredWithoutDiagnosisNestedInput;
};

export type DiagnosisUncheckedUpdateInput = {
    id?: Prisma.IntFieldUpdateOperationsInput | number;
    patientId?: Prisma.StringFieldUpdateOperationsInput | string;
    medicalId?: Prisma.IntFieldUpdateOperationsInput | number;
    doctorId?: Prisma.StringFieldUpdateOperationsInput | string;
    symptoms?: Prisma.StringFieldUpdateOperationsInput | string;
    diagnosis?: Prisma.StringFieldUpdateOperationsInput | string;
    notes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
    prescribedMedications?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
    followUpPlan?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type DiagnosisCreateManyInput = {
    id?: number;
    patientId: string;
    medicalId: number;
    doctorId: string;
    symptoms: string;
    diagnosis: string;
    notes?: string | null;
    prescribedMedications?: string | null;
    followUpPlan?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};

export type DiagnosisUpdateManyMutationInput = {
    patientId?: Prisma.StringFieldUpdateOperationsInput | string;
    symptoms?: Prisma.StringFieldUpdateOperationsInput | string;
    diagnosis?: Prisma.StringFieldUpdateOperationsInput | string;
    notes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
    prescribedMedications?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
    followUpPlan?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type DiagnosisUncheckedUpdateManyInput = {
    id?: Prisma.IntFieldUpdateOperationsInput | number;
    patientId?: Prisma.StringFieldUpdateOperationsInput | string;
    medicalId?: Prisma.IntFieldUpdateOperationsInput | number;
    doctorId?: Prisma.StringFieldUpdateOperationsInput | string;
    symptoms?: Prisma.StringFieldUpdateOperationsInput | string;
    diagnosis?: Prisma.StringFieldUpdateOperationsInput | string;
    notes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
    prescribedMedications?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
    followUpPlan?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type DiagnosisListRelationFilter = {
    every?: Prisma.DiagnosisWhereInput;
    some?: Prisma.DiagnosisWhereInput;
    none?: Prisma.DiagnosisWhereInput;
};

export type DiagnosisOrderByRelationAggregateInput = {
    _count?: Prisma.SortOrder;
};

export type DiagnosisCountOrderByAggregateInput = {
    id?: Prisma.SortOrder;
    patientId?: Prisma.SortOrder;
    medicalId?: Prisma.SortOrder;
    doctorId?: Prisma.SortOrder;
    symptoms?: Prisma.SortOrder;
    diagnosis?: Prisma.SortOrder;
    notes?: Prisma.SortOrder;
    prescribedMedications?: Prisma.SortOrder;
    followUpPlan?: Prisma.SortOrder;
    createdAt?: Prisma.SortOrder;
    updatedAt?: Prisma.SortOrder;
};

export type DiagnosisAvgOrderByAggregateInput = {
    id?: Prisma.SortOrder;
    medicalId?: Prisma.SortOrder;
};

export type DiagnosisMaxOrderByAggregateInput = {
    id?: Prisma.SortOrder;
    patientId?: Prisma.SortOrder;
    medicalId?: Prisma.SortOrder;
    doctorId?: Prisma.SortOrder;
    symptoms?: Prisma.SortOrder;
    diagnosis?: Prisma.SortOrder;
    notes?: Prisma.SortOrder;
    prescribedMedications?: Prisma.SortOrder;
    followUpPlan?: Prisma.SortOrder;
    createdAt?: Prisma.SortOrder;
    updatedAt?: Prisma.SortOrder;
};

export type DiagnosisMinOrderByAggregateInput = {
    id?: Prisma.SortOrder;
    patientId?: Prisma.SortOrder;
    medicalId?: Prisma.SortOrder;
    doctorId?: Prisma.SortOrder;
    symptoms?: Prisma.SortOrder;
    diagnosis?: Prisma.SortOrder;
    notes?: Prisma.SortOrder;
    prescribedMedications?: Prisma.SortOrder;
    followUpPlan?: Prisma.SortOrder;
    createdAt?: Prisma.SortOrder;
    updatedAt?: Prisma.SortOrder;
};

export type DiagnosisSumOrderByAggregateInput = {
    id?: Prisma.SortOrder;
    medicalId?: Prisma.SortOrder;
};

export type DiagnosisCreateNestedManyWithoutDoctorInput = {
    create?:
        | Prisma.XOR<Prisma.DiagnosisCreateWithoutDoctorInput, Prisma.DiagnosisUncheckedCreateWithoutDoctorInput>
        | Prisma.DiagnosisCreateWithoutDoctorInput[]
        | Prisma.DiagnosisUncheckedCreateWithoutDoctorInput[];
    connectOrCreate?:
        | Prisma.DiagnosisCreateOrConnectWithoutDoctorInput
        | Prisma.DiagnosisCreateOrConnectWithoutDoctorInput[];
    createMany?: Prisma.DiagnosisCreateManyDoctorInputEnvelope;
    connect?: Prisma.DiagnosisWhereUniqueInput | Prisma.DiagnosisWhereUniqueInput[];
};

export type DiagnosisUncheckedCreateNestedManyWithoutDoctorInput = {
    create?:
        | Prisma.XOR<Prisma.DiagnosisCreateWithoutDoctorInput, Prisma.DiagnosisUncheckedCreateWithoutDoctorInput>
        | Prisma.DiagnosisCreateWithoutDoctorInput[]
        | Prisma.DiagnosisUncheckedCreateWithoutDoctorInput[];
    connectOrCreate?:
        | Prisma.DiagnosisCreateOrConnectWithoutDoctorInput
        | Prisma.DiagnosisCreateOrConnectWithoutDoctorInput[];
    createMany?: Prisma.DiagnosisCreateManyDoctorInputEnvelope;
    connect?: Prisma.DiagnosisWhereUniqueInput | Prisma.DiagnosisWhereUniqueInput[];
};

export type DiagnosisUpdateManyWithoutDoctorNestedInput = {
    create?:
        | Prisma.XOR<Prisma.DiagnosisCreateWithoutDoctorInput, Prisma.DiagnosisUncheckedCreateWithoutDoctorInput>
        | Prisma.DiagnosisCreateWithoutDoctorInput[]
        | Prisma.DiagnosisUncheckedCreateWithoutDoctorInput[];
    connectOrCreate?:
        | Prisma.DiagnosisCreateOrConnectWithoutDoctorInput
        | Prisma.DiagnosisCreateOrConnectWithoutDoctorInput[];
    upsert?:
        | Prisma.DiagnosisUpsertWithWhereUniqueWithoutDoctorInput
        | Prisma.DiagnosisUpsertWithWhereUniqueWithoutDoctorInput[];
    createMany?: Prisma.DiagnosisCreateManyDoctorInputEnvelope;
    set?: Prisma.DiagnosisWhereUniqueInput | Prisma.DiagnosisWhereUniqueInput[];
    disconnect?: Prisma.DiagnosisWhereUniqueInput | Prisma.DiagnosisWhereUniqueInput[];
    delete?: Prisma.DiagnosisWhereUniqueInput | Prisma.DiagnosisWhereUniqueInput[];
    connect?: Prisma.DiagnosisWhereUniqueInput | Prisma.DiagnosisWhereUniqueInput[];
    update?:
        | Prisma.DiagnosisUpdateWithWhereUniqueWithoutDoctorInput
        | Prisma.DiagnosisUpdateWithWhereUniqueWithoutDoctorInput[];
    updateMany?:
        | Prisma.DiagnosisUpdateManyWithWhereWithoutDoctorInput
        | Prisma.DiagnosisUpdateManyWithWhereWithoutDoctorInput[];
    deleteMany?: Prisma.DiagnosisScalarWhereInput | Prisma.DiagnosisScalarWhereInput[];
};

export type DiagnosisUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?:
        | Prisma.XOR<Prisma.DiagnosisCreateWithoutDoctorInput, Prisma.DiagnosisUncheckedCreateWithoutDoctorInput>
        | Prisma.DiagnosisCreateWithoutDoctorInput[]
        | Prisma.DiagnosisUncheckedCreateWithoutDoctorInput[];
    connectOrCreate?:
        | Prisma.DiagnosisCreateOrConnectWithoutDoctorInput
        | Prisma.DiagnosisCreateOrConnectWithoutDoctorInput[];
    upsert?:
        | Prisma.DiagnosisUpsertWithWhereUniqueWithoutDoctorInput
        | Prisma.DiagnosisUpsertWithWhereUniqueWithoutDoctorInput[];
    createMany?: Prisma.DiagnosisCreateManyDoctorInputEnvelope;
    set?: Prisma.DiagnosisWhereUniqueInput | Prisma.DiagnosisWhereUniqueInput[];
    disconnect?: Prisma.DiagnosisWhereUniqueInput | Prisma.DiagnosisWhereUniqueInput[];
    delete?: Prisma.DiagnosisWhereUniqueInput | Prisma.DiagnosisWhereUniqueInput[];
    connect?: Prisma.DiagnosisWhereUniqueInput | Prisma.DiagnosisWhereUniqueInput[];
    update?:
        | Prisma.DiagnosisUpdateWithWhereUniqueWithoutDoctorInput
        | Prisma.DiagnosisUpdateWithWhereUniqueWithoutDoctorInput[];
    updateMany?:
        | Prisma.DiagnosisUpdateManyWithWhereWithoutDoctorInput
        | Prisma.DiagnosisUpdateManyWithWhereWithoutDoctorInput[];
    deleteMany?: Prisma.DiagnosisScalarWhereInput | Prisma.DiagnosisScalarWhereInput[];
};

export type DiagnosisCreateNestedManyWithoutMedicalInput = {
    create?:
        | Prisma.XOR<Prisma.DiagnosisCreateWithoutMedicalInput, Prisma.DiagnosisUncheckedCreateWithoutMedicalInput>
        | Prisma.DiagnosisCreateWithoutMedicalInput[]
        | Prisma.DiagnosisUncheckedCreateWithoutMedicalInput[];
    connectOrCreate?:
        | Prisma.DiagnosisCreateOrConnectWithoutMedicalInput
        | Prisma.DiagnosisCreateOrConnectWithoutMedicalInput[];
    createMany?: Prisma.DiagnosisCreateManyMedicalInputEnvelope;
    connect?: Prisma.DiagnosisWhereUniqueInput | Prisma.DiagnosisWhereUniqueInput[];
};

export type DiagnosisUncheckedCreateNestedManyWithoutMedicalInput = {
    create?:
        | Prisma.XOR<Prisma.DiagnosisCreateWithoutMedicalInput, Prisma.DiagnosisUncheckedCreateWithoutMedicalInput>
        | Prisma.DiagnosisCreateWithoutMedicalInput[]
        | Prisma.DiagnosisUncheckedCreateWithoutMedicalInput[];
    connectOrCreate?:
        | Prisma.DiagnosisCreateOrConnectWithoutMedicalInput
        | Prisma.DiagnosisCreateOrConnectWithoutMedicalInput[];
    createMany?: Prisma.DiagnosisCreateManyMedicalInputEnvelope;
    connect?: Prisma.DiagnosisWhereUniqueInput | Prisma.DiagnosisWhereUniqueInput[];
};

export type DiagnosisUpdateManyWithoutMedicalNestedInput = {
    create?:
        | Prisma.XOR<Prisma.DiagnosisCreateWithoutMedicalInput, Prisma.DiagnosisUncheckedCreateWithoutMedicalInput>
        | Prisma.DiagnosisCreateWithoutMedicalInput[]
        | Prisma.DiagnosisUncheckedCreateWithoutMedicalInput[];
    connectOrCreate?:
        | Prisma.DiagnosisCreateOrConnectWithoutMedicalInput
        | Prisma.DiagnosisCreateOrConnectWithoutMedicalInput[];
    upsert?:
        | Prisma.DiagnosisUpsertWithWhereUniqueWithoutMedicalInput
        | Prisma.DiagnosisUpsertWithWhereUniqueWithoutMedicalInput[];
    createMany?: Prisma.DiagnosisCreateManyMedicalInputEnvelope;
    set?: Prisma.DiagnosisWhereUniqueInput | Prisma.DiagnosisWhereUniqueInput[];
    disconnect?: Prisma.DiagnosisWhereUniqueInput | Prisma.DiagnosisWhereUniqueInput[];
    delete?: Prisma.DiagnosisWhereUniqueInput | Prisma.DiagnosisWhereUniqueInput[];
    connect?: Prisma.DiagnosisWhereUniqueInput | Prisma.DiagnosisWhereUniqueInput[];
    update?:
        | Prisma.DiagnosisUpdateWithWhereUniqueWithoutMedicalInput
        | Prisma.DiagnosisUpdateWithWhereUniqueWithoutMedicalInput[];
    updateMany?:
        | Prisma.DiagnosisUpdateManyWithWhereWithoutMedicalInput
        | Prisma.DiagnosisUpdateManyWithWhereWithoutMedicalInput[];
    deleteMany?: Prisma.DiagnosisScalarWhereInput | Prisma.DiagnosisScalarWhereInput[];
};

export type DiagnosisUncheckedUpdateManyWithoutMedicalNestedInput = {
    create?:
        | Prisma.XOR<Prisma.DiagnosisCreateWithoutMedicalInput, Prisma.DiagnosisUncheckedCreateWithoutMedicalInput>
        | Prisma.DiagnosisCreateWithoutMedicalInput[]
        | Prisma.DiagnosisUncheckedCreateWithoutMedicalInput[];
    connectOrCreate?:
        | Prisma.DiagnosisCreateOrConnectWithoutMedicalInput
        | Prisma.DiagnosisCreateOrConnectWithoutMedicalInput[];
    upsert?:
        | Prisma.DiagnosisUpsertWithWhereUniqueWithoutMedicalInput
        | Prisma.DiagnosisUpsertWithWhereUniqueWithoutMedicalInput[];
    createMany?: Prisma.DiagnosisCreateManyMedicalInputEnvelope;
    set?: Prisma.DiagnosisWhereUniqueInput | Prisma.DiagnosisWhereUniqueInput[];
    disconnect?: Prisma.DiagnosisWhereUniqueInput | Prisma.DiagnosisWhereUniqueInput[];
    delete?: Prisma.DiagnosisWhereUniqueInput | Prisma.DiagnosisWhereUniqueInput[];
    connect?: Prisma.DiagnosisWhereUniqueInput | Prisma.DiagnosisWhereUniqueInput[];
    update?:
        | Prisma.DiagnosisUpdateWithWhereUniqueWithoutMedicalInput
        | Prisma.DiagnosisUpdateWithWhereUniqueWithoutMedicalInput[];
    updateMany?:
        | Prisma.DiagnosisUpdateManyWithWhereWithoutMedicalInput
        | Prisma.DiagnosisUpdateManyWithWhereWithoutMedicalInput[];
    deleteMany?: Prisma.DiagnosisScalarWhereInput | Prisma.DiagnosisScalarWhereInput[];
};

export type DiagnosisCreateWithoutDoctorInput = {
    patientId: string;
    symptoms: string;
    diagnosis: string;
    notes?: string | null;
    prescribedMedications?: string | null;
    followUpPlan?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    medical: Prisma.MedicalRecordsCreateNestedOneWithoutDiagnosisInput;
};

export type DiagnosisUncheckedCreateWithoutDoctorInput = {
    id?: number;
    patientId: string;
    medicalId: number;
    symptoms: string;
    diagnosis: string;
    notes?: string | null;
    prescribedMedications?: string | null;
    followUpPlan?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};

export type DiagnosisCreateOrConnectWithoutDoctorInput = {
    where: Prisma.DiagnosisWhereUniqueInput;
    create: Prisma.XOR<Prisma.DiagnosisCreateWithoutDoctorInput, Prisma.DiagnosisUncheckedCreateWithoutDoctorInput>;
};

export type DiagnosisCreateManyDoctorInputEnvelope = {
    data: Prisma.DiagnosisCreateManyDoctorInput | Prisma.DiagnosisCreateManyDoctorInput[];
    skipDuplicates?: boolean;
};

export type DiagnosisUpsertWithWhereUniqueWithoutDoctorInput = {
    where: Prisma.DiagnosisWhereUniqueInput;
    update: Prisma.XOR<Prisma.DiagnosisUpdateWithoutDoctorInput, Prisma.DiagnosisUncheckedUpdateWithoutDoctorInput>;
    create: Prisma.XOR<Prisma.DiagnosisCreateWithoutDoctorInput, Prisma.DiagnosisUncheckedCreateWithoutDoctorInput>;
};

export type DiagnosisUpdateWithWhereUniqueWithoutDoctorInput = {
    where: Prisma.DiagnosisWhereUniqueInput;
    data: Prisma.XOR<Prisma.DiagnosisUpdateWithoutDoctorInput, Prisma.DiagnosisUncheckedUpdateWithoutDoctorInput>;
};

export type DiagnosisUpdateManyWithWhereWithoutDoctorInput = {
    where: Prisma.DiagnosisScalarWhereInput;
    data: Prisma.XOR<Prisma.DiagnosisUpdateManyMutationInput, Prisma.DiagnosisUncheckedUpdateManyWithoutDoctorInput>;
};

export type DiagnosisScalarWhereInput = {
    AND?: Prisma.DiagnosisScalarWhereInput | Prisma.DiagnosisScalarWhereInput[];
    OR?: Prisma.DiagnosisScalarWhereInput[];
    NOT?: Prisma.DiagnosisScalarWhereInput | Prisma.DiagnosisScalarWhereInput[];
    id?: Prisma.IntFilter<'Diagnosis'> | number;
    patientId?: Prisma.StringFilter<'Diagnosis'> | string;
    medicalId?: Prisma.IntFilter<'Diagnosis'> | number;
    doctorId?: Prisma.StringFilter<'Diagnosis'> | string;
    symptoms?: Prisma.StringFilter<'Diagnosis'> | string;
    diagnosis?: Prisma.StringFilter<'Diagnosis'> | string;
    notes?: Prisma.StringNullableFilter<'Diagnosis'> | string | null;
    prescribedMedications?: Prisma.StringNullableFilter<'Diagnosis'> | string | null;
    followUpPlan?: Prisma.StringNullableFilter<'Diagnosis'> | string | null;
    createdAt?: Prisma.DateTimeFilter<'Diagnosis'> | Date | string;
    updatedAt?: Prisma.DateTimeFilter<'Diagnosis'> | Date | string;
};

export type DiagnosisCreateWithoutMedicalInput = {
    patientId: string;
    symptoms: string;
    diagnosis: string;
    notes?: string | null;
    prescribedMedications?: string | null;
    followUpPlan?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    doctor: Prisma.DoctorCreateNestedOneWithoutDiagnosisInput;
};

export type DiagnosisUncheckedCreateWithoutMedicalInput = {
    id?: number;
    patientId: string;
    doctorId: string;
    symptoms: string;
    diagnosis: string;
    notes?: string | null;
    prescribedMedications?: string | null;
    followUpPlan?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};

export type DiagnosisCreateOrConnectWithoutMedicalInput = {
    where: Prisma.DiagnosisWhereUniqueInput;
    create: Prisma.XOR<Prisma.DiagnosisCreateWithoutMedicalInput, Prisma.DiagnosisUncheckedCreateWithoutMedicalInput>;
};

export type DiagnosisCreateManyMedicalInputEnvelope = {
    data: Prisma.DiagnosisCreateManyMedicalInput | Prisma.DiagnosisCreateManyMedicalInput[];
    skipDuplicates?: boolean;
};

export type DiagnosisUpsertWithWhereUniqueWithoutMedicalInput = {
    where: Prisma.DiagnosisWhereUniqueInput;
    update: Prisma.XOR<Prisma.DiagnosisUpdateWithoutMedicalInput, Prisma.DiagnosisUncheckedUpdateWithoutMedicalInput>;
    create: Prisma.XOR<Prisma.DiagnosisCreateWithoutMedicalInput, Prisma.DiagnosisUncheckedCreateWithoutMedicalInput>;
};

export type DiagnosisUpdateWithWhereUniqueWithoutMedicalInput = {
    where: Prisma.DiagnosisWhereUniqueInput;
    data: Prisma.XOR<Prisma.DiagnosisUpdateWithoutMedicalInput, Prisma.DiagnosisUncheckedUpdateWithoutMedicalInput>;
};

export type DiagnosisUpdateManyWithWhereWithoutMedicalInput = {
    where: Prisma.DiagnosisScalarWhereInput;
    data: Prisma.XOR<Prisma.DiagnosisUpdateManyMutationInput, Prisma.DiagnosisUncheckedUpdateManyWithoutMedicalInput>;
};

export type DiagnosisCreateManyDoctorInput = {
    id?: number;
    patientId: string;
    medicalId: number;
    symptoms: string;
    diagnosis: string;
    notes?: string | null;
    prescribedMedications?: string | null;
    followUpPlan?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};

export type DiagnosisUpdateWithoutDoctorInput = {
    patientId?: Prisma.StringFieldUpdateOperationsInput | string;
    symptoms?: Prisma.StringFieldUpdateOperationsInput | string;
    diagnosis?: Prisma.StringFieldUpdateOperationsInput | string;
    notes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
    prescribedMedications?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
    followUpPlan?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    medical?: Prisma.MedicalRecordsUpdateOneRequiredWithoutDiagnosisNestedInput;
};

export type DiagnosisUncheckedUpdateWithoutDoctorInput = {
    id?: Prisma.IntFieldUpdateOperationsInput | number;
    patientId?: Prisma.StringFieldUpdateOperationsInput | string;
    medicalId?: Prisma.IntFieldUpdateOperationsInput | number;
    symptoms?: Prisma.StringFieldUpdateOperationsInput | string;
    diagnosis?: Prisma.StringFieldUpdateOperationsInput | string;
    notes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
    prescribedMedications?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
    followUpPlan?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type DiagnosisUncheckedUpdateManyWithoutDoctorInput = {
    id?: Prisma.IntFieldUpdateOperationsInput | number;
    patientId?: Prisma.StringFieldUpdateOperationsInput | string;
    medicalId?: Prisma.IntFieldUpdateOperationsInput | number;
    symptoms?: Prisma.StringFieldUpdateOperationsInput | string;
    diagnosis?: Prisma.StringFieldUpdateOperationsInput | string;
    notes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
    prescribedMedications?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
    followUpPlan?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type DiagnosisCreateManyMedicalInput = {
    id?: number;
    patientId: string;
    doctorId: string;
    symptoms: string;
    diagnosis: string;
    notes?: string | null;
    prescribedMedications?: string | null;
    followUpPlan?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};

export type DiagnosisUpdateWithoutMedicalInput = {
    patientId?: Prisma.StringFieldUpdateOperationsInput | string;
    symptoms?: Prisma.StringFieldUpdateOperationsInput | string;
    diagnosis?: Prisma.StringFieldUpdateOperationsInput | string;
    notes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
    prescribedMedications?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
    followUpPlan?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    doctor?: Prisma.DoctorUpdateOneRequiredWithoutDiagnosisNestedInput;
};

export type DiagnosisUncheckedUpdateWithoutMedicalInput = {
    id?: Prisma.IntFieldUpdateOperationsInput | number;
    patientId?: Prisma.StringFieldUpdateOperationsInput | string;
    doctorId?: Prisma.StringFieldUpdateOperationsInput | string;
    symptoms?: Prisma.StringFieldUpdateOperationsInput | string;
    diagnosis?: Prisma.StringFieldUpdateOperationsInput | string;
    notes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
    prescribedMedications?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
    followUpPlan?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type DiagnosisUncheckedUpdateManyWithoutMedicalInput = {
    id?: Prisma.IntFieldUpdateOperationsInput | number;
    patientId?: Prisma.StringFieldUpdateOperationsInput | string;
    doctorId?: Prisma.StringFieldUpdateOperationsInput | string;
    symptoms?: Prisma.StringFieldUpdateOperationsInput | string;
    diagnosis?: Prisma.StringFieldUpdateOperationsInput | string;
    notes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
    prescribedMedications?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
    followUpPlan?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type DiagnosisSelect<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = runtime.Types.Extensions.GetSelect<
    {
        id?: boolean;
        patientId?: boolean;
        medicalId?: boolean;
        doctorId?: boolean;
        symptoms?: boolean;
        diagnosis?: boolean;
        notes?: boolean;
        prescribedMedications?: boolean;
        followUpPlan?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        doctor?: boolean | Prisma.DoctorDefaultArgs<ExtArgs>;
        medical?: boolean | Prisma.MedicalRecordsDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['diagnosis']
>;

export type DiagnosisSelectCreateManyAndReturn<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = runtime.Types.Extensions.GetSelect<
    {
        id?: boolean;
        patientId?: boolean;
        medicalId?: boolean;
        doctorId?: boolean;
        symptoms?: boolean;
        diagnosis?: boolean;
        notes?: boolean;
        prescribedMedications?: boolean;
        followUpPlan?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        doctor?: boolean | Prisma.DoctorDefaultArgs<ExtArgs>;
        medical?: boolean | Prisma.MedicalRecordsDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['diagnosis']
>;

export type DiagnosisSelectUpdateManyAndReturn<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = runtime.Types.Extensions.GetSelect<
    {
        id?: boolean;
        patientId?: boolean;
        medicalId?: boolean;
        doctorId?: boolean;
        symptoms?: boolean;
        diagnosis?: boolean;
        notes?: boolean;
        prescribedMedications?: boolean;
        followUpPlan?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        doctor?: boolean | Prisma.DoctorDefaultArgs<ExtArgs>;
        medical?: boolean | Prisma.MedicalRecordsDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['diagnosis']
>;

export type DiagnosisSelectScalar = {
    id?: boolean;
    patientId?: boolean;
    medicalId?: boolean;
    doctorId?: boolean;
    symptoms?: boolean;
    diagnosis?: boolean;
    notes?: boolean;
    prescribedMedications?: boolean;
    followUpPlan?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
};

export type DiagnosisOmit<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = runtime.Types.Extensions.GetOmit<
    | 'id'
    | 'patientId'
    | 'medicalId'
    | 'doctorId'
    | 'symptoms'
    | 'diagnosis'
    | 'notes'
    | 'prescribedMedications'
    | 'followUpPlan'
    | 'createdAt'
    | 'updatedAt',
    ExtArgs['result']['diagnosis']
>;
export type DiagnosisInclude<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
    doctor?: boolean | Prisma.DoctorDefaultArgs<ExtArgs>;
    medical?: boolean | Prisma.MedicalRecordsDefaultArgs<ExtArgs>;
};
export type DiagnosisIncludeCreateManyAndReturn<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
    doctor?: boolean | Prisma.DoctorDefaultArgs<ExtArgs>;
    medical?: boolean | Prisma.MedicalRecordsDefaultArgs<ExtArgs>;
};
export type DiagnosisIncludeUpdateManyAndReturn<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
    doctor?: boolean | Prisma.DoctorDefaultArgs<ExtArgs>;
    medical?: boolean | Prisma.MedicalRecordsDefaultArgs<ExtArgs>;
};

export type $DiagnosisPayload<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
    name: 'Diagnosis';
    objects: {
        doctor: Prisma.$DoctorPayload<ExtArgs>;
        medical: Prisma.$MedicalRecordsPayload<ExtArgs>;
    };
    scalars: runtime.Types.Extensions.GetPayloadResult<
        {
            id: number;
            patientId: string;
            medicalId: number;
            doctorId: string;
            symptoms: string;
            diagnosis: string;
            notes: string | null;
            prescribedMedications: string | null;
            followUpPlan: string | null;
            createdAt: Date;
            updatedAt: Date;
        },
        ExtArgs['result']['diagnosis']
    >;
    composites: {};
};

export type DiagnosisGetPayload<S extends boolean | null | undefined | DiagnosisDefaultArgs> =
    runtime.Types.Result.GetResult<Prisma.$DiagnosisPayload, S>;

export type DiagnosisCountArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = Omit<DiagnosisFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: DiagnosisCountAggregateInputType | true;
};

export interface DiagnosisDelegate<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
    GlobalOmitOptions = {}
> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Diagnosis']; meta: { name: 'Diagnosis' } };
    /**
     * Find zero or one Diagnosis that matches the filter.
     * @param {DiagnosisFindUniqueArgs} args - Arguments to find a Diagnosis
     * @example
     * // Get one Diagnosis
     * const diagnosis = await prisma.diagnosis.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DiagnosisFindUniqueArgs>(
        args: Prisma.SelectSubset<T, DiagnosisFindUniqueArgs<ExtArgs>>
    ): Prisma.Prisma__DiagnosisClient<
        runtime.Types.Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
        null,
        ExtArgs,
        GlobalOmitOptions
    >;

    /**
     * Find one Diagnosis that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DiagnosisFindUniqueOrThrowArgs} args - Arguments to find a Diagnosis
     * @example
     * // Get one Diagnosis
     * const diagnosis = await prisma.diagnosis.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DiagnosisFindUniqueOrThrowArgs>(
        args: Prisma.SelectSubset<T, DiagnosisFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma.Prisma__DiagnosisClient<
        runtime.Types.Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
        never,
        ExtArgs,
        GlobalOmitOptions
    >;

    /**
     * Find the first Diagnosis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisFindFirstArgs} args - Arguments to find a Diagnosis
     * @example
     * // Get one Diagnosis
     * const diagnosis = await prisma.diagnosis.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DiagnosisFindFirstArgs>(
        args?: Prisma.SelectSubset<T, DiagnosisFindFirstArgs<ExtArgs>>
    ): Prisma.Prisma__DiagnosisClient<
        runtime.Types.Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
        null,
        ExtArgs,
        GlobalOmitOptions
    >;

    /**
     * Find the first Diagnosis that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisFindFirstOrThrowArgs} args - Arguments to find a Diagnosis
     * @example
     * // Get one Diagnosis
     * const diagnosis = await prisma.diagnosis.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DiagnosisFindFirstOrThrowArgs>(
        args?: Prisma.SelectSubset<T, DiagnosisFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma.Prisma__DiagnosisClient<
        runtime.Types.Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
        never,
        ExtArgs,
        GlobalOmitOptions
    >;

    /**
     * Find zero or more Diagnoses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Diagnoses
     * const diagnoses = await prisma.diagnosis.findMany()
     *
     * // Get first 10 Diagnoses
     * const diagnoses = await prisma.diagnosis.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const diagnosisWithIdOnly = await prisma.diagnosis.findMany({ select: { id: true } })
     *
     */
    findMany<T extends DiagnosisFindManyArgs>(
        args?: Prisma.SelectSubset<T, DiagnosisFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
        runtime.Types.Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a Diagnosis.
     * @param {DiagnosisCreateArgs} args - Arguments to create a Diagnosis.
     * @example
     * // Create one Diagnosis
     * const Diagnosis = await prisma.diagnosis.create({
     *   data: {
     *     // ... data to create a Diagnosis
     *   }
     * })
     *
     */
    create<T extends DiagnosisCreateArgs>(
        args: Prisma.SelectSubset<T, DiagnosisCreateArgs<ExtArgs>>
    ): Prisma.Prisma__DiagnosisClient<
        runtime.Types.Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
        never,
        ExtArgs,
        GlobalOmitOptions
    >;

    /**
     * Create many Diagnoses.
     * @param {DiagnosisCreateManyArgs} args - Arguments to create many Diagnoses.
     * @example
     * // Create many Diagnoses
     * const diagnosis = await prisma.diagnosis.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends DiagnosisCreateManyArgs>(
        args?: Prisma.SelectSubset<T, DiagnosisCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<Prisma.BatchPayload>;

    /**
     * Create many Diagnoses and returns the data saved in the database.
     * @param {DiagnosisCreateManyAndReturnArgs} args - Arguments to create many Diagnoses.
     * @example
     * // Create many Diagnoses
     * const diagnosis = await prisma.diagnosis.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Diagnoses and only return the `id`
     * const diagnosisWithIdOnly = await prisma.diagnosis.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends DiagnosisCreateManyAndReturnArgs>(
        args?: Prisma.SelectSubset<T, DiagnosisCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
        runtime.Types.Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>
    >;

    /**
     * Delete a Diagnosis.
     * @param {DiagnosisDeleteArgs} args - Arguments to delete one Diagnosis.
     * @example
     * // Delete one Diagnosis
     * const Diagnosis = await prisma.diagnosis.delete({
     *   where: {
     *     // ... filter to delete one Diagnosis
     *   }
     * })
     *
     */
    delete<T extends DiagnosisDeleteArgs>(
        args: Prisma.SelectSubset<T, DiagnosisDeleteArgs<ExtArgs>>
    ): Prisma.Prisma__DiagnosisClient<
        runtime.Types.Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
        never,
        ExtArgs,
        GlobalOmitOptions
    >;

    /**
     * Update one Diagnosis.
     * @param {DiagnosisUpdateArgs} args - Arguments to update one Diagnosis.
     * @example
     * // Update one Diagnosis
     * const diagnosis = await prisma.diagnosis.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends DiagnosisUpdateArgs>(
        args: Prisma.SelectSubset<T, DiagnosisUpdateArgs<ExtArgs>>
    ): Prisma.Prisma__DiagnosisClient<
        runtime.Types.Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
        never,
        ExtArgs,
        GlobalOmitOptions
    >;

    /**
     * Delete zero or more Diagnoses.
     * @param {DiagnosisDeleteManyArgs} args - Arguments to filter Diagnoses to delete.
     * @example
     * // Delete a few Diagnoses
     * const { count } = await prisma.diagnosis.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends DiagnosisDeleteManyArgs>(
        args?: Prisma.SelectSubset<T, DiagnosisDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<Prisma.BatchPayload>;

    /**
     * Update zero or more Diagnoses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Diagnoses
     * const diagnosis = await prisma.diagnosis.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends DiagnosisUpdateManyArgs>(
        args: Prisma.SelectSubset<T, DiagnosisUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<Prisma.BatchPayload>;

    /**
     * Update zero or more Diagnoses and returns the data updated in the database.
     * @param {DiagnosisUpdateManyAndReturnArgs} args - Arguments to update many Diagnoses.
     * @example
     * // Update many Diagnoses
     * const diagnosis = await prisma.diagnosis.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Diagnoses and only return the `id`
     * const diagnosisWithIdOnly = await prisma.diagnosis.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends DiagnosisUpdateManyAndReturnArgs>(
        args: Prisma.SelectSubset<T, DiagnosisUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
        runtime.Types.Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>
    >;

    /**
     * Create or update one Diagnosis.
     * @param {DiagnosisUpsertArgs} args - Arguments to update or create a Diagnosis.
     * @example
     * // Update or create a Diagnosis
     * const diagnosis = await prisma.diagnosis.upsert({
     *   create: {
     *     // ... data to create a Diagnosis
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Diagnosis we want to update
     *   }
     * })
     */
    upsert<T extends DiagnosisUpsertArgs>(
        args: Prisma.SelectSubset<T, DiagnosisUpsertArgs<ExtArgs>>
    ): Prisma.Prisma__DiagnosisClient<
        runtime.Types.Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
        never,
        ExtArgs,
        GlobalOmitOptions
    >;

    /**
     * Count the number of Diagnoses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisCountArgs} args - Arguments to filter Diagnoses to count.
     * @example
     * // Count the number of Diagnoses
     * const count = await prisma.diagnosis.count({
     *   where: {
     *     // ... the filter for the Diagnoses we want to count
     *   }
     * })
     **/
    count<T extends DiagnosisCountArgs>(
        args?: Prisma.Subset<T, DiagnosisCountArgs>
    ): Prisma.PrismaPromise<
        T extends runtime.Types.Utils.Record<'select', any>
            ? T['select'] extends true
                ? number
                : Prisma.GetScalarType<T['select'], DiagnosisCountAggregateOutputType>
            : number
    >;

    /**
     * Allows you to perform aggregations operations on a Diagnosis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends DiagnosisAggregateArgs>(
        args: Prisma.Subset<T, DiagnosisAggregateArgs>
    ): Prisma.PrismaPromise<GetDiagnosisAggregateType<T>>;

    /**
     * Group by Diagnosis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
        T extends DiagnosisGroupByArgs,
        HasSelectOrTake extends Prisma.Or<
            Prisma.Extends<'skip', Prisma.Keys<T>>,
            Prisma.Extends<'take', Prisma.Keys<T>>
        >,
        OrderByArg extends Prisma.True extends HasSelectOrTake
            ? { orderBy: DiagnosisGroupByArgs['orderBy'] }
            : { orderBy?: DiagnosisGroupByArgs['orderBy'] },
        OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
        ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
        ByValid extends Prisma.Has<ByFields, OrderFields>,
        HavingFields extends Prisma.GetHavingFields<T['having']>,
        HavingValid extends Prisma.Has<ByFields, HavingFields>,
        ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
        InputErrors extends ByEmpty extends Prisma.True
            ? `Error: "by" must not be empty.`
            : HavingValid extends Prisma.False
              ? {
                    [P in HavingFields]: P extends ByFields
                        ? never
                        : P extends string
                          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                          : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
                }[HavingFields]
              : 'take' extends Prisma.Keys<T>
                ? 'orderBy' extends Prisma.Keys<T>
                    ? ByValid extends Prisma.True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                          }[OrderFields]
                    : 'Error: If you provide "take", you also need to provide "orderBy"'
                : 'skip' extends Prisma.Keys<T>
                  ? 'orderBy' extends Prisma.Keys<T>
                      ? ByValid extends Prisma.True
                          ? {}
                          : {
                                [P in OrderFields]: P extends ByFields
                                    ? never
                                    : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                            }[OrderFields]
                      : 'Error: If you provide "skip", you also need to provide "orderBy"'
                  : ByValid extends Prisma.True
                    ? {}
                    : {
                          [P in OrderFields]: P extends ByFields
                              ? never
                              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                      }[OrderFields]
    >(
        args: Prisma.SubsetIntersection<T, DiagnosisGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetDiagnosisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Diagnosis model
     */
    readonly fields: DiagnosisFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for Diagnosis.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__DiagnosisClient<
    T,
    Null = never,
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
    GlobalOmitOptions = {}
> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    doctor<T extends Prisma.DoctorDefaultArgs<ExtArgs> = {}>(
        args?: Prisma.Subset<T, Prisma.DoctorDefaultArgs<ExtArgs>>
    ): Prisma.Prisma__DoctorClient<
        | runtime.Types.Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
        | Null,
        Null,
        ExtArgs,
        GlobalOmitOptions
    >;
    medical<T extends Prisma.MedicalRecordsDefaultArgs<ExtArgs> = {}>(
        args?: Prisma.Subset<T, Prisma.MedicalRecordsDefaultArgs<ExtArgs>>
    ): Prisma.Prisma__MedicalRecordsClient<
        | runtime.Types.Result.GetResult<
              Prisma.$MedicalRecordsPayload<ExtArgs>,
              T,
              'findUniqueOrThrow',
              GlobalOmitOptions
          >
        | Null,
        Null,
        ExtArgs,
        GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
        onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
        onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
        onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): runtime.Types.Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>;
}

/**
 * Fields of the Diagnosis model
 */
export interface DiagnosisFieldRefs {
    readonly id: Prisma.FieldRef<'Diagnosis', 'Int'>;
    readonly patientId: Prisma.FieldRef<'Diagnosis', 'String'>;
    readonly medicalId: Prisma.FieldRef<'Diagnosis', 'Int'>;
    readonly doctorId: Prisma.FieldRef<'Diagnosis', 'String'>;
    readonly symptoms: Prisma.FieldRef<'Diagnosis', 'String'>;
    readonly diagnosis: Prisma.FieldRef<'Diagnosis', 'String'>;
    readonly notes: Prisma.FieldRef<'Diagnosis', 'String'>;
    readonly prescribedMedications: Prisma.FieldRef<'Diagnosis', 'String'>;
    readonly followUpPlan: Prisma.FieldRef<'Diagnosis', 'String'>;
    readonly createdAt: Prisma.FieldRef<'Diagnosis', 'DateTime'>;
    readonly updatedAt: Prisma.FieldRef<'Diagnosis', 'DateTime'>;
}

// Custom InputTypes
/**
 * Diagnosis findUnique
 */
export type DiagnosisFindUniqueArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: Prisma.DiagnosisSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Diagnosis
     */
    omit?: Prisma.DiagnosisOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.DiagnosisInclude<ExtArgs> | null;
    /**
     * Filter, which Diagnosis to fetch.
     */
    where: Prisma.DiagnosisWhereUniqueInput;
};

/**
 * Diagnosis findUniqueOrThrow
 */
export type DiagnosisFindUniqueOrThrowArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: Prisma.DiagnosisSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Diagnosis
     */
    omit?: Prisma.DiagnosisOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.DiagnosisInclude<ExtArgs> | null;
    /**
     * Filter, which Diagnosis to fetch.
     */
    where: Prisma.DiagnosisWhereUniqueInput;
};

/**
 * Diagnosis findFirst
 */
export type DiagnosisFindFirstArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: Prisma.DiagnosisSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Diagnosis
     */
    omit?: Prisma.DiagnosisOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.DiagnosisInclude<ExtArgs> | null;
    /**
     * Filter, which Diagnosis to fetch.
     */
    where?: Prisma.DiagnosisWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Diagnoses to fetch.
     */
    orderBy?: Prisma.DiagnosisOrderByWithRelationInput | Prisma.DiagnosisOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Diagnoses.
     */
    cursor?: Prisma.DiagnosisWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Diagnoses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Diagnoses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Diagnoses.
     */
    distinct?: Prisma.DiagnosisScalarFieldEnum | Prisma.DiagnosisScalarFieldEnum[];
};

/**
 * Diagnosis findFirstOrThrow
 */
export type DiagnosisFindFirstOrThrowArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: Prisma.DiagnosisSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Diagnosis
     */
    omit?: Prisma.DiagnosisOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.DiagnosisInclude<ExtArgs> | null;
    /**
     * Filter, which Diagnosis to fetch.
     */
    where?: Prisma.DiagnosisWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Diagnoses to fetch.
     */
    orderBy?: Prisma.DiagnosisOrderByWithRelationInput | Prisma.DiagnosisOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Diagnoses.
     */
    cursor?: Prisma.DiagnosisWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Diagnoses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Diagnoses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Diagnoses.
     */
    distinct?: Prisma.DiagnosisScalarFieldEnum | Prisma.DiagnosisScalarFieldEnum[];
};

/**
 * Diagnosis findMany
 */
export type DiagnosisFindManyArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: Prisma.DiagnosisSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Diagnosis
     */
    omit?: Prisma.DiagnosisOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.DiagnosisInclude<ExtArgs> | null;
    /**
     * Filter, which Diagnoses to fetch.
     */
    where?: Prisma.DiagnosisWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Diagnoses to fetch.
     */
    orderBy?: Prisma.DiagnosisOrderByWithRelationInput | Prisma.DiagnosisOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Diagnoses.
     */
    cursor?: Prisma.DiagnosisWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Diagnoses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Diagnoses.
     */
    skip?: number;
    distinct?: Prisma.DiagnosisScalarFieldEnum | Prisma.DiagnosisScalarFieldEnum[];
};

/**
 * Diagnosis create
 */
export type DiagnosisCreateArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: Prisma.DiagnosisSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Diagnosis
     */
    omit?: Prisma.DiagnosisOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.DiagnosisInclude<ExtArgs> | null;
    /**
     * The data needed to create a Diagnosis.
     */
    data: Prisma.XOR<Prisma.DiagnosisCreateInput, Prisma.DiagnosisUncheckedCreateInput>;
};

/**
 * Diagnosis createMany
 */
export type DiagnosisCreateManyArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
    /**
     * The data used to create many Diagnoses.
     */
    data: Prisma.DiagnosisCreateManyInput | Prisma.DiagnosisCreateManyInput[];
    skipDuplicates?: boolean;
};

/**
 * Diagnosis createManyAndReturn
 */
export type DiagnosisCreateManyAndReturnArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: Prisma.DiagnosisSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Diagnosis
     */
    omit?: Prisma.DiagnosisOmit<ExtArgs> | null;
    /**
     * The data used to create many Diagnoses.
     */
    data: Prisma.DiagnosisCreateManyInput | Prisma.DiagnosisCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.DiagnosisIncludeCreateManyAndReturn<ExtArgs> | null;
};

/**
 * Diagnosis update
 */
export type DiagnosisUpdateArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: Prisma.DiagnosisSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Diagnosis
     */
    omit?: Prisma.DiagnosisOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.DiagnosisInclude<ExtArgs> | null;
    /**
     * The data needed to update a Diagnosis.
     */
    data: Prisma.XOR<Prisma.DiagnosisUpdateInput, Prisma.DiagnosisUncheckedUpdateInput>;
    /**
     * Choose, which Diagnosis to update.
     */
    where: Prisma.DiagnosisWhereUniqueInput;
};

/**
 * Diagnosis updateMany
 */
export type DiagnosisUpdateManyArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
    /**
     * The data used to update Diagnoses.
     */
    data: Prisma.XOR<Prisma.DiagnosisUpdateManyMutationInput, Prisma.DiagnosisUncheckedUpdateManyInput>;
    /**
     * Filter which Diagnoses to update
     */
    where?: Prisma.DiagnosisWhereInput;
    /**
     * Limit how many Diagnoses to update.
     */
    limit?: number;
};

/**
 * Diagnosis updateManyAndReturn
 */
export type DiagnosisUpdateManyAndReturnArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: Prisma.DiagnosisSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Diagnosis
     */
    omit?: Prisma.DiagnosisOmit<ExtArgs> | null;
    /**
     * The data used to update Diagnoses.
     */
    data: Prisma.XOR<Prisma.DiagnosisUpdateManyMutationInput, Prisma.DiagnosisUncheckedUpdateManyInput>;
    /**
     * Filter which Diagnoses to update
     */
    where?: Prisma.DiagnosisWhereInput;
    /**
     * Limit how many Diagnoses to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.DiagnosisIncludeUpdateManyAndReturn<ExtArgs> | null;
};

/**
 * Diagnosis upsert
 */
export type DiagnosisUpsertArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: Prisma.DiagnosisSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Diagnosis
     */
    omit?: Prisma.DiagnosisOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.DiagnosisInclude<ExtArgs> | null;
    /**
     * The filter to search for the Diagnosis to update in case it exists.
     */
    where: Prisma.DiagnosisWhereUniqueInput;
    /**
     * In case the Diagnosis found by the `where` argument doesn't exist, create a new Diagnosis with this data.
     */
    create: Prisma.XOR<Prisma.DiagnosisCreateInput, Prisma.DiagnosisUncheckedCreateInput>;
    /**
     * In case the Diagnosis was found with the provided `where` argument, update it with this data.
     */
    update: Prisma.XOR<Prisma.DiagnosisUpdateInput, Prisma.DiagnosisUncheckedUpdateInput>;
};

/**
 * Diagnosis delete
 */
export type DiagnosisDeleteArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: Prisma.DiagnosisSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Diagnosis
     */
    omit?: Prisma.DiagnosisOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.DiagnosisInclude<ExtArgs> | null;
    /**
     * Filter which Diagnosis to delete.
     */
    where: Prisma.DiagnosisWhereUniqueInput;
};

/**
 * Diagnosis deleteMany
 */
export type DiagnosisDeleteManyArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
    /**
     * Filter which Diagnoses to delete
     */
    where?: Prisma.DiagnosisWhereInput;
    /**
     * Limit how many Diagnoses to delete.
     */
    limit?: number;
};

/**
 * Diagnosis without action
 */
export type DiagnosisDefaultArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: Prisma.DiagnosisSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Diagnosis
     */
    omit?: Prisma.DiagnosisOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.DiagnosisInclude<ExtArgs> | null;
};
